<!DOCTYPE html>
<html>

<head>
<title>Pong</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/103/three.min.js"></script>

<script>
   var stepX = 0.10;
   var stepY = 0.15;
   var start = false;
   var colision_top = true;
   var colision_down = false;

   var combo;
   var teams = ['Roma','Cartago'];
   var position_text = [-8.5,0,6];
   var team_ok = false;

   function init() {
      const canvas = document.querySelector('#c');
      var scene = new THREE.Scene();
      //Anchura de la escena
      var sceneWidth = window.innerWidth - 20;
      //Altura del escenario
      var sceneHeight = window.innerHeight - 20;
      //Perspectiva de la cámara.(Ángulo en grados de la cámara,relación de aspecto, Corte cercano, Corte lejano)
      var camera = new THREE.PerspectiveCamera(90, sceneWidth / sceneHeight, 0.01, 100);
      //Posición de la cámara
      camera.position.set(0, -15, 5);
      camera.lookAt(scene.position);
      //Suavizado de bordes activado
      var renderer = new THREE.WebGLRenderer({
         antialias : true,
      });
      //Habilitamos la sombra en el renderer
      renderer.shadowMap.enabled = true;
      renderer.setSize(sceneWidth, sceneHeight);
      document.body.appendChild(renderer.domElement);
      background(scene);
      count_cpu = 0;
      count_user = 0;
      text("txt_mesh", scene,teams[1] + ' ' + count_cpu +'-'+ count_user+' '+ teams[0]);
      count = [count_cpu,count_user];

      renderer.render(scene, camera);

      var light = getLight();
      var ambient_light = getAmbient_Light();
      //getBorder(lugar,ancho_x,profundidad_y,altura_z,donde empezamos a contar_X,Y y Z)
      var leftBorder = getBorder("left", 1, 24, 2, -6.5, 0, 0);
      var rightBorder = getBorder("right", 1, 24, 2, 6.5, 0, 0);
      var topBorder = getBorder("top_border", 14, 1, 2, 0, 12, 0);
      var downBorder = getBorder("down_border", 14, 1, 2, 0, -12, 0);

      var cpuBorder = getBorder("top", 2, 2, 2, 0, 10, 1);
      var userBorder = getBorder("down", 2, 2, 2, 0, -10, 1);

      var sphere = getSphere();
      var sphere_border1 = getSphere_Border(-6,12);
      var sphere_border2 = getSphere_Border(6,-12);
      var sphere_border3 = getSphere_Border(-6,-12);
      var sphere_border4 = getSphere_Border(6,12);
      var floor = getFloor();

      var floor_oval = Oval_Scenario();
      var lateral_derecho = getGrada(12,0,0,-1,15,38);
      var lateral_izquierdo = getGrada(-12,0,0,1,15,38);
      var fondo_norte = getGrada(0,15,1,0,32,15);
      var border_fondo = getBorder("fondo_up",36,1,13,0,20,0)
      var border_lateral_right = getBorder("border_lateral_right",1,42,13,17,0,0);
      var border_lateral_left = getBorder("border_lateral_left",1,42,13,-17,0,0);

      //Añadimos los elementos al escenario
      scene.add(light);
      scene.add(ambient_light);
      scene.add(leftBorder);
      scene.add(rightBorder);
      scene.add(topBorder);
      scene.add(downBorder);

      scene.add(cpuBorder);
      scene.add(userBorder);

      scene.add(sphere);
      scene.add(sphere_border1);
      scene.add(sphere_border2);
      scene.add(sphere_border3);
      scene.add(sphere_border4);
      scene.add(floor);

      scene.add(floor_oval);

      scene.add(lateral_derecho);
      scene.add(fondo_norte);
      scene.add(lateral_izquierdo);

      scene.add(border_fondo)
      scene.add(border_lateral_right);
      scene.add(border_lateral_left);

      var borders = [ leftBorder, rightBorder, cpuBorder, userBorder];
      if (team_ok) {
        text("txt_mesh",scene,teams[1]+' ' + count[0] +'-'+ count[1]+' ' +teams[0]);
        animate(sphere, borders, renderer, scene, camera,count);
      }else {
        select_team(scene,teams);
        animate(sphere, borders, renderer, scene, camera,count);
      }

 }
   function select_team(scene,teams) {
     document.onkeydown = function (ev){
       switch (ev.key) {
         case '1':
          teams[0] = 'Roma';
          team_ok = true;
          break;
        case '2':
          teams[0] = 'Egipto';
          team_ok = true;
          break;
        case '3':
          teams[0] = 'Hispania';
          team_ok = true;
          break;
       default:
       console.log("No team");
       }
     }
   }
   function animate(sphere, borders, renderer, scene, camera,count) {
     if (start) {
       checkCollision(sphere, borders, count, scene);
       movement_ball(sphere);
     }
      movement_borders(borders,sphere);
      renderer.render(scene, camera);
        requestAnimationFrame(function() {
           animate(sphere, borders, renderer, scene, camera,count);
        }); }
   function movement_ball(sphere) {
     sphere.position.x += stepX;
     sphere.position.y += stepY;
     sphere.rotation.x += stepX;
     sphere.rotation.y += stepY;
   }
   function movement_CPU(borders,sphere) {
     if (borders[2].position.x < sphere.position.x) {
        borders[2].position.x += 0.05;
     }else if (borders[2].position.x > sphere.position.x) {
         borders[2].position.x += -0.05;
     }
   }
   function movement_borders(borders,sphere) {
     movement_CPU(borders,sphere);
     document.onkeydown = function (ev){
       switch (ev.key) {
         case 'ArrowLeft':
         if (borders[3].position.x > -5) {
             borders[3].position.x += -0.3;
         }
          break;
        case 'ArrowRight':
        if (borders[3].position.x < 5) {
          borders[3].position.x += +0.3;
        }
          break;
        case 'Enter':
          if (!start) {
            start = true;
          }
          break;
       default:

       }
     }
   }

   function getLight() {
      var light = new THREE.DirectionalLight();
      light.position.set(-4, -2, 4);
      light.castShadow = true;
      light.shadow.camera.near = 0;
      light.shadow.camera.far = 16;
      light.shadow.camera.left = -8;
      light.shadow.camera.right = 5;
      light.shadow.camera.top = 10;
      light.shadow.camera.bottom = -10;
      light.shadow.mapSize.width = 4096;
      light.shadow.mapSize.height = 4096;
      return light;
   }
   function getAmbient_Light() {
     var ambient_light = new THREE.AmbientLight(0X404040);
     return ambient_light;
   }

   function getSphere() {
      var geometry = new THREE.SphereGeometry(1, 20, 20);
      //var material = new THREE.MeshNormalMaterial();
      //var mesh = new THREE.Mesh(geometry, material);
      var mesh = new THREE.Mesh(geometry, getMaterial("metal.jpg",1,1));
      mesh.position.z = 1;
      mesh.rotation.x = 1;
      mesh.castShadow = true;
      mesh.name = "sphere";

      return mesh;
   }
   function getSphere_Border(x,y) {
      var geometry = new THREE.SphereGeometry(0.8, 20, 20);
      //var material = new THREE.MeshNormalMaterial();
      //var mesh = new THREE.Mesh(geometry, material);
      var mesh = new THREE.Mesh(geometry, getMaterial("wood.png",4,4));
      mesh.position.z = 1.8;
      mesh.position.y = y;
      mesh.position.x = x;
      mesh.castShadow = true;
      mesh.name = "sphere";

      return mesh;
   }
   function Oval_Scenario() {
     var geometry = new THREE.PlaneGeometry(25, 30);
     var mesh = new THREE.Mesh(geometry, getMaterial("arena.jpg",25,25));
     mesh.receiveShadow = true;
     mesh.position.z = -0.1;
     return mesh;
   }
   function getGrada(x,y,rot_x,rot_y,tam_x,tam_y) {
     var geometry = new THREE.PlaneGeometry(tam_x,tam_y);
     if (tam_x>tam_y) {
       var mesh = new THREE.Mesh(geometry, getMaterial("sillar_piedra_fondo.jpg",20,10));
     }else {
       var mesh = new THREE.Mesh(geometry, getMaterial("sillar_piedra.jpg",10,20));
     }
     mesh.position.x = x;
     mesh.position.y = y;
     mesh.rotation.x = rot_x;
     mesh.rotation.y = rot_y;
     mesh.receiveShadow = true;
     return mesh;
   }

   function getFloor() {
      var geometry = new THREE.PlaneGeometry(14, 24);
      var mesh = new THREE.Mesh(geometry, getMaterial("marmol.jpg",1,1));
      mesh.receiveShadow = true;

      return mesh;
   }
   function getBorder(name, x, y, z, posX, posY, posZ) {
      var geometry = new THREE.BoxGeometry(x, y, z);
      if (name == "top") {
        var mesh = new THREE.Mesh(geometry, getMaterial("carthago.png",1,1));
      }else if (name == "down") {
        var mesh = new THREE.Mesh(geometry, getMaterial("rome.jpg",1,1));
      }else if (name == "down_border") {
        var mesh = new THREE.Mesh(geometry, getMaterial("col.jpg",1,24));
      }else {
        var mesh = new THREE.Mesh(geometry, getMaterial("col.jpg",1,3));
      }
      mesh.receiveShadow = true;
      mesh.position.set(posX, posY, posZ);
      mesh.name = name;

      return mesh;
   }
   function getMaterial(name,rows,column) {
     var texture = new THREE.TextureLoader().load(name);
     var material = new THREE.MeshPhysicalMaterial({
        map : texture
     });
     material.map.wrapS = material.map.wrapT = THREE.RepeatWrapping;
     material.map.repeat.set(column, rows);
     material.side = THREE.DoubleSide;

     return material;
   }
   function background(scene) {
     const fondo = new THREE.TextureLoader();
     const bgTexture = fondo.load('cielo.jpg');
     scene.background = bgTexture;
   }
   function text(name, scene, txt) {
     var loader = new THREE.FontLoader();
     loader.load('helvetiker_regular.typeface.json', function (font) {
       var selectedObject = scene.getObjectByName(name);
       if (selectedObject) {
         scene.remove(selectedObject);
       }
       var textGeometry = new THREE.TextGeometry(txt,{
        font: font,
        size: 1.5,
        height: 0.1,
        curveSegments: 12,
        bevelEnabled: false,
        bevelThickness: 0.1,
        bevelSize: 0.1,
        bevelOffset: 0,
        bevelSegments: 1,
      } );
     var txt_mat = new THREE.MeshBasicMaterial({color:0xFFA000});
     var txt_mesh = new THREE.Mesh(textGeometry, txt_mat);
     txt_mesh.name = name;
     txt_mesh.position.set(position_text[0],position_text[1],position_text[2]);
     txt_mesh.rotation.x = -5;
     scene.add(txt_mesh);
   });}
   function checkCollision(sphere, borders, count,scene) {
      var originPosition = sphere.position.clone();

      for (var i = 0; i < sphere.geometry.vertices.length; i++) {
         var localVertex = sphere.geometry.vertices[i].clone();
         var globalVertex = localVertex.applyMatrix4(sphere.matrix);
         var directionVector = globalVertex.sub(sphere.position);
         var ray = new THREE.Raycaster(originPosition, directionVector.clone().normalize());
         var collisionResults = ray.intersectObjects(borders);
         if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length()) {
            // Collision detected
            if (collisionResults[0].object.name == "left" || collisionResults[0].object.name == "right") {
              stepX *= -1;
            }
            if (collisionResults[0].object.name == "down" || collisionResults[0].object.name == "top") {
                if (collisionResults[0].object.name == "down" && colision_down) {
                  stepY *= -1;
                }else if (collisionResults[0].object.name == "top" && colision_top) {
                  stepY *= -1;
                }
                if (collisionResults[0].object.name == "down") {
                    colision_down = false;
                    colision_top = true;
                }else {
                  colision_top = false;
                  colision_down = true;
                }
               //stepY *= -1;
               x = stepX;
               y = stepY;
               if (combo) {
                 combo = false;
                 stepX *= (1/6);
                 stepY *= (1/5);
               }
               if (collisionResults[0].distance > 0.99 && !(combo)) {
                 combo = true;
                 stepX *= 6;
                 stepY *= 5;
               }
            }

            break;
         }

         if (sphere.position.y < -10 || sphere.position.y > 10) {
            if (sphere.position.y < -10) {
              count[0] += 1;
            }else {
              count[1]+= 1;
            }
            start = false;
            text("txt_mesh",scene,teams[1]+' ' + count[0] +'-'+ count[1]+' ' +teams[0]);
            sphere.position.x = 0;
            sphere.position.y = 0;
            if (combo) {
              combo = false;
              stepX *= (1/6);
              stepY *= (1/5);
            }
            if (count[0] == 5 ||count[1] == 5) {
              stepX = 0;
              stepY = 0;
            }

         }
      }
   }
</script>
</head>

<body onload="init()">
</body>

</html>
